# Name Kethan Pilla
# Course: CS 410w
# Assignment 12
# Date: 02/24/ 2025
# Description: This program generates a list of random numbers and sends them to child processes.

#!/usr/bin/perl

#Validate command line arguments.
die("The number of arguments should be exactly 4\n") if (@ARGV != 4);

$begin      = $ARGV[0];
$end        = $ARGV[1];
$count      = $ARGV[2];
$childCount = $ARGV[3];

die("Should be a positive number to begin with\n") if ($begin < 0);
die("The ending should be greater than the beginning\n") if ($end < $begin);
die("The count should be between 50 and 1000\n") if ($count < 50 || $count > 1000);
die("The number of child processes should be between 2 and 6\n") if ($childCount < 2 || $childCount > 6);
 
print "Number of child processes: $childCount\n";
print "Range of numbers: $begin through $end\n";
print "Numbers generated by each process: $count\n";

# Create pipes for communication.
for ($i = 0; $i < $childCount; $i++) {
    # Pipe for child-to-parent communication.
    pipe($ch2pa_in[$i], $ch2pa_out[$i]) or die("Pipe error\n");
    # Pipe for parent-to-child communication.
    pipe($pa2ch_in[$i], $pa2ch_out[$i]) or die("Pipe error\n");
}

# Fork child processes.
for ($i = 0; $i < $childCount; $i++) {
    $childIndex = $i;  # Save the child's index for later reporting.
    $ids[$i] = fork();
    if ($ids[$i] == 0) {
        # CHILD PROCESS:
        close($ch2pa_in[$childIndex]);    # Close parent's read end.
        close($pa2ch_out[$childIndex]);     # Close parent's write end.

        $sum = 0;
        for ($j = 0; $j < $count; $j++) {
            $num = int(rand($end - $begin + 1)) + $begin;
            $sum += $num;
            $numbers[$j] = $num;
        }
        $childMean = $sum / $count;

        # Send the child's sum to the parent.
        print { $ch2pa_out[$childIndex] } "$sum\n";
        close($ch2pa_out[$childIndex]);

        # Receive the global mean from the parent.
        $globalMean = <$pa2ch_in[$childIndex]>;
        chomp($globalMean);
        close($pa2ch_in[$childIndex]);

        $below = 0;
        $above = 0;
        for ($j = 0; $j < $count; $j++) {
            if ($numbers[$j] < $globalMean) {
                $below++;
            }
            elsif ($numbers[$j] > $globalMean) {
                $above++;
            }
        }

        # Display summary line.
        # Format: Process (child index), PID, local mean, count below, count above.
        printf(" %d\t%d\t%.2f\t%d\t%d\n", $childIndex, $$, $childMean, $below, $above);
        exit(0);
    }
    else {
        # PARENT PROCESS:
        $childPIDs[$i] = $ids[$i];
        close($ch2pa_out[$i]);   # Parent doesn't write on this pipe.
        close($pa2ch_in[$i]);    # Parent doesn't read on this pipe.
    }
}

# Parent collects the sums from each child and computes the global mean.
$totalSum = 0;
for ($i = 0; $i < $childCount; $i++) {
    $childSum = <$ch2pa_in[$i]>;
    chomp($childSum);
    $totalSum = $totalSum + $childSum;
    close($ch2pa_in[$i]);
}
$totalNumbers = $childCount * $count;
$globalMean = sprintf("%.2f", $totalSum / $totalNumbers);

print "Global mean (rounded to nearest hundredth): $globalMean\n\n";
print "Analysis compared to the global mean:\n\n";
print "Process\tPID\tMean\tBelow\tAbove\n";
print "-------\t-----\t------\t-----\t-----\n";

# Send the global mean to each child.
for ($i = 0; $i < $childCount; $i++) {
    print {$pa2ch_out[$i]} "$globalMean\n";
    close($pa2ch_out[$i]);
}

# Wait for all child processes to finish.
for ($i = 0; $i < $childCount; $i++) {
    wait();
}

